<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>async_hll_rcon.connection API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>async_hll_rcon.connection</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import inspect
from functools import wraps
from itertools import cycle
from typing import Callable, Self

import trio
from loguru import logger

from async_hll_rcon import constants
from async_hll_rcon.typedefs import FailedGameServerCommand, FailedGameServerResponse
from async_hll_rcon.validators import (
    _gamestate_validator,
    _on_off_validator,
    _player_info_validator,
    _success_fail_validator,
)


class HllConnection:
    &#34;&#34;&#34;Represents an underlying low level socket connection to the game server and returns raw results

    Performs minmal to no validation/error checking because all of that is done in AsyncRcon

    &#34;&#34;&#34;

    def __init__(
        self,
        ip_addr: str,
        port: int,
        password: str,
        receive_timeout: int = constants.TCP_TIMEOUT_READ,
        tcp_timeout: int = constants.TCP_TIMEOUT,
    ) -&gt; None:
        self.ip_addr = ip_addr
        self.port = int(port)
        self.password = password
        self.receive_timeout = receive_timeout
        self.tcp_timeout = tcp_timeout
        self.xor_key: bytes
        self._connection: trio.SocketStream | None = None
        self.logged_in = False

    def _validate_timeout(self, value: float) -&gt; None:
        &#34;&#34;&#34;Check that value is float like and positive for TCP timeouts&#34;&#34;&#34;
        try:
            float(value)
        except ValueError:
            raise ValueError(
                f&#34;`receive_timeout={value}` must be a float or castable to a float&#34;
            )

        if value &lt; 0:
            raise ValueError(f&#34;`receive_timeout={value}` must be &gt;= 0&#34;)

    @property
    def receive_timeout(self) -&gt; float:
        return self._receive_timeout

    @receive_timeout.setter
    def receive_timeout(self, value: float) -&gt; None:
        self._validate_timeout(value)

        self._receive_timeout = value

    @property
    def tcp_timeout(self) -&gt; float:
        return self._tcp_timeout

    @tcp_timeout.setter
    def tcp_timeout(self, value: float) -&gt; None:
        self._validate_timeout(value)

        self._tcp_timeout = value

    @property
    def connection(self) -&gt; trio.SocketStream:
        &#34;&#34;&#34;Safety check to make sure an unconnected instance isn&#39;t used&#34;&#34;&#34;
        if self._connection is not None:
            return self._connection
        else:
            raise ValueError(&#34;Socket connection to the game server not established.&#34;)

    @staticmethod
    def _xor_encode(
        message: str | bytes, xor_key: bytes, encoding: str = &#34;utf-8&#34;
    ) -&gt; bytes:
        &#34;&#34;&#34;XOR encrypt the given message with the given XOR key&#34;&#34;&#34;
        if isinstance(message, str):
            message = message.encode(encoding=encoding)

        return bytes(
            [
                message_char ^ xor_char
                for message_char, xor_char in zip(message, cycle(xor_key))
            ]
        )

    @staticmethod
    def _xor_decode(cipher_text: str | bytes, xor_key: bytes) -&gt; str:
        &#34;&#34;&#34;XOR decrypt the given cipher text with the given XOR key&#34;&#34;&#34;
        return HllConnection._xor_encode(cipher_text, xor_key).decode(&#34;utf-8&#34;)

    @classmethod
    async def setup(
        cls,
        ip_addr: str,
        port: int,
        password: str,
        receive_timeout: int,
        tcp_timeout: int,
    ) -&gt; Self:
        &#34;&#34;&#34;Create and return an instance after it has connected to the game server&#34;&#34;&#34;
        instance = HllConnection(ip_addr, port, password, receive_timeout, tcp_timeout)
        await instance.connect()
        return instance

    async def _connect(self) -&gt; None:
        &#34;&#34;&#34;Open a socket to the game server and retrieve the XOR key&#34;&#34;&#34;
        with trio.fail_after(self.tcp_timeout):
            self._connection = await trio.open_tcp_stream(self.ip_addr, self.port)

        # The very first thing the game server will return is the XOR key that all
        # subsequent requests require for encoding/decoding
        with trio.fail_after(self.tcp_timeout):
            self.xor_key = await self._receive_from_game_server()

    async def connect(self) -&gt; None:
        &#34;&#34;&#34;Connect to and log into the game server&#34;&#34;&#34;
        await self._connect()
        await self.login()

    async def _receive_from_game_server(
        self,
        max_bytes: int
        | None = constants.CHUNK_SIZE,  # TODO allow configuration for this
        validator: Callable | None = None,
        **kwargs,
    ) -&gt; bytes:
        &#34;&#34;&#34;Accumulate chunks of bytes from the game server and return them

        The game server does not indicate end of blocks of data in any way and does not
        send the empty (b&#34;&#34;) value trio would need to iterate over the connection. Instead
        we repeatedly try to read from the socket until we time out at self.receive_timeout
        seconds and then return all the accumulated data
        &#34;&#34;&#34;

        buffer = bytearray()
        while True:
            try:
                with trio.fail_after(self.receive_timeout):
                    buffer += await self.connection.receive_some(max_bytes)

                    # The game server does not send back any sort of EOF marker
                    # so there is no way to know when we&#39;re actually done, some
                    # return values can be identified as complete and valid return
                    # results, and if so we can return early, otherwise we block
                    # until we time out
                    logger.debug(f&#34;{validator=}&#34;)
                    if validator and validator(
                        self._xor_decode(buffer, self.xor_key), **kwargs
                    ):
                        logger.debug(f&#34;breaking on complete chunk&#34;)
                        break

            except trio.TooSlowError:
                if validator:
                    logger.error(
                        f&#34;Timed out in {id(self)} buffer=`{self._xor_decode(buffer, self.xor_key)}`&#34;
                    )
                    raise
                break

        return bytes(buffer)

    async def _send_to_game_server(
        self,
        content: str,
        response_validator: Callable | None = None,
        retry_attempts: int = 2,
        **kwargs,
    ) -&gt; str:
        &#34;&#34;&#34;XOR the content and send to the game server, returning the game server response&#34;&#34;&#34;
        logger.debug(f&#34;{id(self)} {len(content)=} {content=}&#34;)
        xored_content = HllConnection._xor_encode(content, self.xor_key)
        result = None
        for _ in range(retry_attempts):
            try:
                with trio.fail_after(self.tcp_timeout):
                    logger.debug(f&#34;sending content=`{content}`&#34;)
                    await self.connection.send_all(xored_content)
                    result = await self._receive_from_game_server(
                        validator=response_validator, **kwargs
                    )
                    break
            except (FailedGameServerResponse, trio.TooSlowError) as e:
                logger.error(
                    f&#34;{id(self)} {content=} {len(content)=} Failed attempt #{_+1}/{retry_attempts} {e}&#34;
                )
                continue

        if not result:
            raise FailedGameServerCommand

        logger.warning(f&#34;received {len(result)=} bytes&#34;)

        return HllConnection._xor_decode(result, self.xor_key)

    async def login(self) -&gt; str:
        &#34;&#34;&#34;Log into the game server with the ip/port/password provided during initialization

        Returns:
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Login {self.password}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_server_name(self) -&gt; str:
        &#34;&#34;&#34;Return the server name as defined in the game server `Server.ini` file&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Name&#34;
        return await self._send_to_game_server(content)

    async def get_current_max_player_slots(self) -&gt; str:
        &#34;&#34;&#34;Return the number of players currently on the server and max players in the form X/Y&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Slots&#34;
        return await self._send_to_game_server(content)

    async def get_gamestate(self) -&gt; str:
        &#34;&#34;&#34;Return the current round state

        Returns
            A string, including newlines in the format:

            Players: Allied: 46 - Axis: 46
            Score: Allied: 4 - Axis: 1
            Remaining Time: 0:25:23
            Map: carentan_offensive_ger
            Next Map: hurtgenforest_warfare_V2

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get GameState&#34;
        return await self._send_to_game_server(
            content, response_validator=_gamestate_validator
        )

    async def get_max_queue_size(self) -&gt; str:
        &#34;&#34;&#34;Return the maximum number of players allowed in the queue to join the server&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get MaxQueuedPlayers&#34;
        return await self._send_to_game_server(content)

    async def set_max_queue_size(self, size: int) -&gt; str:
        &#34;&#34;&#34;Set the maximum number of players allowed in the queue to join the server (0 &lt;= size &lt;= 6)

        Returns
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetMaxQueuedPlayers {size}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_num_vip_slots(self) -&gt; str:
        &#34;&#34;&#34;Returns the number of reserved VIP slots&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get NumVipSlots&#34;
        return await self._send_to_game_server(content)

    async def set_num_vip_slots(self, amount: int) -&gt; str:
        &#34;&#34;&#34;Set the number of reserved VIP slots on the server

        For example, setting this to 2 on a 100 slot server would only allow players
        with VIP access to join once 98 players are connected (regardless of those
        players VIP status)

        Returns
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({amount=})&#34;  # type: ignore
        )
        content = f&#34;SetNumVipSlots {amount}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def set_welcome_message(self, message: str) -&gt; str:
        &#34;&#34;&#34;Set the server welcome message

        Returns
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({message=})&#34;  # type: ignore
        )
        content = f&#34;Say {message}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def set_broadcast_message(self, message: str | None) -&gt; str:
        &#34;&#34;&#34;Set the current broadcast message, or clear it if message is None

        As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({message=})&#34;  # type: ignore
        )
        if message:
            content = f&#34;Broadcast {message}&#34;
        else:
            raise NotImplementedError
            content = f&#34;Broadcast  &#34;

        logger.debug(f&#34;{content=}&#34;)
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def clear_broadcast_message(self) -&gt; str:
        &#34;&#34;&#34;Clear the current broadcast message

        As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken
        &#34;&#34;&#34;
        raise NotImplementedError
        return await self.set_broadcast_message(None)

    async def get_game_logs(self, minutes: int, filter: str | None = None) -&gt; str:
        &#34;&#34;&#34;Return a new line delimited list of game logs

        Args
            minutes: The number of minutes worth of logs to return, it is not possible to retrieve
                logs after server restarts
            filter: Return only logs that contain this string in them

        Returns
            A string of log lines delimited by new lines, certain log types may contain new lines such as KICKs or MESSAGES
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({minutes=}, {filter=})&#34;  # type: ignore
        )
        if filter is None:
            filter = &#34;&#34;

        content = f&#39;ShowLog {minutes} &#34;{filter}&#34;&#39;
        return await self._send_to_game_server(content)

    async def get_current_map(self) -&gt; str:
        &#34;&#34;&#34;Return the current map name&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Map&#34;
        return await self._send_to_game_server(content)

    async def get_available_maps(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of all available map names.&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get MapsForRotation&#34;
        return await self._send_to_game_server(content)

    async def get_map_rotation(self) -&gt; str:
        &#34;&#34;&#34;Return a newline delimited string of the currently set map rotation names&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;RotList&#34;
        return await self._send_to_game_server(content)

    async def add_map_to_rotation(
        self,
        name: str,
        after_map_name: str | None = None,
        after_map_ordinal: int | None = None,
    ) -&gt; str:
        &#34;&#34;&#34;Add the map to the rotation in the specified spot, appends to the end of the rotation by default

        Returns
            SUCCESS or game server error messages
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;RotAdd {name} {after_map_name or &#39;&#39;} {after_map_ordinal or &#39;&#39;}&#34;
        return await self._send_to_game_server(content)

    async def remove_map_from_rotation(self, name: str, ordinal: int | None = 1) -&gt; str:
        &#34;&#34;&#34;Remove the specified map instance from the rotation

        Returns
            SUCCESS or game server error messages
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;RotDel {name} {ordinal or &#39;&#39;}&#34;
        return await self._send_to_game_server(content)

    async def set_current_map(self, name: str, ordinal: int | None = 1) -&gt; str:
        &#34;&#34;&#34;Immediately change the game server to the map after a 60 second delay, the map must be in the rotation

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Map {name} {ordinal or &#39;&#39;}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_players(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of player names currently connected to the game server&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Players&#34;
        return await self._send_to_game_server(content)

    async def get_player_steam_ids(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of player names and steam IDs in the format player_name : steam_id_64&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get PlayerIds&#34;
        return await self._send_to_game_server(content)

    async def get_admin_ids(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of admins and their roles

        See also get_admin_groups()

        Returns
            tab delimited list in the form: steam_id_64 role &#34;name&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AdminIds&#34;
        return await self._send_to_game_server(content)

    async def get_admin_groups(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of available admin roles&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AdminGroups&#34;
        return await self._send_to_game_server(content)

    async def add_admin(
        self, steam_id_64: str, role: str, name: str | None = None
    ) -&gt; str:
        &#34;&#34;&#34;Grant the specified steam ID the specified role

        Role must be valid, see get_admin_groups()

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;AdminAdd {steam_id_64} {role} {name or &#39;&#39;}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_admin(self, steam_id_64: str) -&gt; str:
        &#34;&#34;&#34;Remove all admin roles from the specified steam ID, see get_admin_groups() for possible admin roles

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;AdminDel {steam_id_64}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_vip_ids(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of VIP steam ID 64s and names&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get VipIds&#34;
        return await self._send_to_game_server(content)

    async def get_player_info(self, player_name: str) -&gt; str:
        &#34;&#34;&#34;Return detailed player info for the given player name

        Returns
            New line delimited string in the form:

            Name: Muller
            steamID64: 76561198148668981
            Team: Axis
            Role: HeavyMachineGunner
            Unit: 2 - CHARLIE
            Loadout: Standard Issue
            Kills: 39 - Deaths: 30
            Score: C 389, O 380, D 920, S 30
            Level: 77

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({player_name=})&#34;  # type: ignore
        )
        content = f&#34;PlayerInfo {player_name}&#34;
        result = await self._send_to_game_server(
            content, _player_info_validator, player_name=player_name, conn_id=id(self)
        )

        logger.debug(f&#34;{id(self)} {result=}&#34;)
        return result

    async def add_vip(self, steam_id_64: str, name: str | None) -&gt; str:
        &#34;&#34;&#34;Grant VIP status to the given steam ID

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;VipAdd {steam_id_64} {name}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_vip(self, steam_id_64: str) -&gt; str:
        &#34;&#34;&#34;Remove VIP status from the given steam ID

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;VipDel {steam_id_64}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_temp_bans(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of temporary ban lists&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get TempBans&#34;
        return await self._send_to_game_server(content)

    async def get_permanent_bans(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of permanent ban lists&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get PermaBans&#34;
        return await self._send_to_game_server(content)

    async def message_player(
        self,
        message: str,
        steam_id_64: str | None = None,
        player_name: str | None = None,
    ) -&gt; str:
        &#34;&#34;&#34;Send an in game message to the specified player

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#39;Message &#34;{steam_id_64 or player_name}&#34; &#34;{message}&#34;&#39;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def punish_player(self, player_name: str, reason: str | None = None) -&gt; str:
        &#34;&#34;&#34;Punish (kill in game) the specified player, will fail if they are not spawned

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Punish {player_name} {reason}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def switch_player_on_death(self, player_name: str) -&gt; str:
        &#34;&#34;&#34;Switch a player to the other team after their next death

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SwitchTeamOnDeath {player_name}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def switch_player_now(self, player_name: str) -&gt; str:
        &#34;&#34;&#34;Immediately switch a player to the other team

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SwitchTeamNow {player_name}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def kick_player(self, player_name: str, reason: str | None = None) -&gt; str:
        &#34;&#34;&#34;Remove a player from the server and show them the indicated reason

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Kick {player_name} {reason}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def temp_ban_player(
        self,
        steam_id_64: str | None = None,
        player_name: str | None = None,
        duration_hours: int | None = None,
        reason: str | None = None,
        by_admin_name: str | None = None,
    ) -&gt; str:
        &#34;&#34;&#34;Ban a player from the server for the given number of hours and show them the indicated reason

        Args
            steam_id_64: optional if player name is provided
            player_name: optional if steam_id_64 is provided, will use steam_id_64 if both are passed
            duration_hours: number of hours to ban, will be cleared on game server restart, defaults to 2 if not provided
            reason: optional reason for the ban that is shown to the player
            by_admin_name: optional name for which admin or automated service banned the player
        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )

        if duration_hours is None:
            validated_duration = &#34;&#34;
        else:
            validated_duration = str(duration_hours)

        if reason is None:
            reason = &#34;&#34;

        if by_admin_name is None:
            by_admin_name = &#34;&#34;

        content = f&#39;TempBan &#34;{steam_id_64 or player_name}&#34; {validated_duration} &#34;{reason}&#34; &#34;{by_admin_name}&#34;&#39;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def perma_ban_player(
        self,
        steam_id_64: str | None = None,
        player_name: str | None = None,
        reason: str | None = None,
        by_admin_name: str | None = None,
    ) -&gt; str:
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        &#34;&#34;&#34;Permanently ban a player and show them the indicated reason

        Args
            steam_id_64: optional if player name is provided
            player_name: optional if steam_id_64 is provided, will use steam_id_64 if both are passed
            reason: optional reason for the ban that is shown to the player
            by_admin_name: optional name for which admin or automated service banned the player

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;

        if reason is None:
            reason = &#34;&#34;

        if by_admin_name is None:
            by_admin_name = &#34;&#34;

        content = (
            f&#39;PermaBan &#34;{steam_id_64 or player_name}&#34; &#34;{reason}&#34; &#34;{by_admin_name}&#34;&#39;
        )
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_temp_ban(self, ban_log: str) -&gt; str:
        &#34;&#34;&#34;Remove a temporary ban from a player

        Args
            ban_log: Must match the HLL ban log format returned from get_temp_bans

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;PardonTempBan {ban_log}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_perma_ban(self, ban_log: str) -&gt; str:
        &#34;&#34;&#34;Remove a permanent ban from a player

        Args
            ban_log: Must match the HLL ban log format returned from get_permanent_bans()

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;PardonPermaBan {ban_log}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_idle_kick_time(self) -&gt; str:
        &#34;&#34;&#34;Return the current idle kick time in minutes&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Idletime&#34;
        return await self._send_to_game_server(content)

    async def set_idle_kick_time(self, threshold_minutes: int) -&gt; str:
        &#34;&#34;&#34;Set the idle kick time in minutes

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetKickIdleTime {threshold_minutes}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_high_ping_limit(self) -&gt; str:
        &#34;&#34;&#34;Return the high ping limit in milliseconds&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get HighPing&#34;
        return await self._send_to_game_server(content)

    async def set_high_ping_limit(self, threshold: int) -&gt; str:
        &#34;&#34;&#34;Set the high ping limit (player is kicked when they exceed) in milliseconds

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetHighPing {threshold}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def disable_high_ping_limit(self) -&gt; str:
        &#34;&#34;&#34;Disable (set to 0) the high ping limit

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        return await self.set_high_ping_limit(0)

    async def get_team_switch_cooldown(self) -&gt; str:
        &#34;&#34;&#34;Return the current team switch cool down in minutes&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get TeamSwitchCooldown&#34;
        return await self._send_to_game_server(content)

    async def set_team_switch_cooldown(self, cooldown: int) -&gt; str:
        &#34;&#34;&#34;Set the team switch cool down in minutes

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetTeamSwitchCooldown {cooldown}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_auto_balance_enabled(self) -&gt; str:
        &#34;&#34;&#34;Return if team auto balance (enforced differences in team sizes) is enabled

        Returns
            &#39;on&#39; or &#39;off&#39;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AutoBalanceEnabled&#34;
        return await self._send_to_game_server(
            content, response_validator=_on_off_validator
        )

    async def enable_auto_balance(self) -&gt; str:
        &#34;&#34;&#34;Enable the team auto balance (enforced differences in team sizes) feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetAutobalanceEnabled {constants.HLL_BOOL_ENABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def disable_auto_balance(self) -&gt; str:
        &#34;&#34;&#34;Disable the team auto balance (enforced differences in team sizes) feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetAutobalanceEnabled {constants.HLL_BOOL_DISABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_auto_balance_threshold(self) -&gt; str:
        &#34;&#34;&#34;Return the allowed team size difference before players are forced to join the other team&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AutoBalanceThreshold&#34;
        return await self._send_to_game_server(content)

    async def set_auto_balance_threshold(self, threshold: int) -&gt; str:
        &#34;&#34;&#34;Set the allowed team size difference before players are forced to join the other team

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetAutoBalanceThreshold {threshold}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_vote_kick_enabled(self) -&gt; str:
        &#34;&#34;&#34;Return if vote to kick players is enabled

        Returns
            &#39;on&#39; or &#39;off&#39;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get VoteKickEnabled&#34;
        return await self._send_to_game_server(
            content, response_validator=_on_off_validator
        )

    async def enable_vote_kick(self) -&gt; str:
        &#34;&#34;&#34;Enable the vote to kick players feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;

        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetVoteKickEnabled  {constants.HLL_BOOL_ENABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def disable_vote_kick(self) -&gt; str:
        &#34;&#34;&#34;Disable the vote to kick players feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetVoteKickEnabled  {constants.HLL_BOOL_DISABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_vote_kick_thresholds(self) -&gt; str:
        &#34;&#34;&#34;Return the required number of votes to remove from the server in threshold pairs

        Returns
            A comma separated list in the form: players, votes required for instance 0,1,10,5
                means when 10 players are on, 5 votes are required to remove a player
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get VoteKickThreshold&#34;
        return await self._send_to_game_server(content)

    async def set_vote_kick_thresholds(self, threshold_pairs: str) -&gt; str:
        &#34;&#34;&#34;Set vote kick threshold pairs, the first entry must be for 0 players

        Args
            threshold_pairs: A comma separated list in the form: players, votes required for instance 0,1,10,5
                means when 10 players are on, 5 votes are required to remove a player
        Returns
            SUCCESS or FAIL or error message
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetVoteKickThreshold {threshold_pairs}&#34;

        # This validator won&#39;t work 100% of the time since this can return error messages
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def clear_vote_kick_threshold(self) -&gt; str:
        &#34;&#34;&#34;Clear vote kick threshold pairs

        Removes all the threshold pairs, the game server does not appear to have defaults

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;ResetVoteKickThreshold&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_censored_words(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of all words that will be censored in game chat&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Profanity&#34;
        return await self._send_to_game_server(content)

    async def censor_words(self, words: str) -&gt; str:
        &#34;&#34;&#34;Append a comma delimited list of words to censor in game chat

        Args
            words: Must be a comma separated list, white space between commas is preserved
                and words are appended, adding a word that already exists will return SUCCESS
                but the word will not be duplicated

        Returns
            SUCCESS or FAIL

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;BanProfanity {words}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def uncensor_words(self, words: str) -&gt; str:
        &#34;&#34;&#34;Remove a comma delimited list of words to censor in game chat

        Args
            words: Must be a comma separated list, response_validator=_success_fail_validator, white space between commas is preserved

        Returns
            SUCCESS or FAIL

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;UnbanProfanity {words}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="async_hll_rcon.connection.HllConnection"><code class="flex name class">
<span>class <span class="ident">HllConnection</span></span>
<span>(</span><span>ip_addr: str, port: int, password: str, receive_timeout: int = 6, tcp_timeout: int = 25)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents an underlying low level socket connection to the game server and returns raw results</p>
<p>Performs minmal to no validation/error checking because all of that is done in AsyncRcon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HllConnection:
    &#34;&#34;&#34;Represents an underlying low level socket connection to the game server and returns raw results

    Performs minmal to no validation/error checking because all of that is done in AsyncRcon

    &#34;&#34;&#34;

    def __init__(
        self,
        ip_addr: str,
        port: int,
        password: str,
        receive_timeout: int = constants.TCP_TIMEOUT_READ,
        tcp_timeout: int = constants.TCP_TIMEOUT,
    ) -&gt; None:
        self.ip_addr = ip_addr
        self.port = int(port)
        self.password = password
        self.receive_timeout = receive_timeout
        self.tcp_timeout = tcp_timeout
        self.xor_key: bytes
        self._connection: trio.SocketStream | None = None
        self.logged_in = False

    def _validate_timeout(self, value: float) -&gt; None:
        &#34;&#34;&#34;Check that value is float like and positive for TCP timeouts&#34;&#34;&#34;
        try:
            float(value)
        except ValueError:
            raise ValueError(
                f&#34;`receive_timeout={value}` must be a float or castable to a float&#34;
            )

        if value &lt; 0:
            raise ValueError(f&#34;`receive_timeout={value}` must be &gt;= 0&#34;)

    @property
    def receive_timeout(self) -&gt; float:
        return self._receive_timeout

    @receive_timeout.setter
    def receive_timeout(self, value: float) -&gt; None:
        self._validate_timeout(value)

        self._receive_timeout = value

    @property
    def tcp_timeout(self) -&gt; float:
        return self._tcp_timeout

    @tcp_timeout.setter
    def tcp_timeout(self, value: float) -&gt; None:
        self._validate_timeout(value)

        self._tcp_timeout = value

    @property
    def connection(self) -&gt; trio.SocketStream:
        &#34;&#34;&#34;Safety check to make sure an unconnected instance isn&#39;t used&#34;&#34;&#34;
        if self._connection is not None:
            return self._connection
        else:
            raise ValueError(&#34;Socket connection to the game server not established.&#34;)

    @staticmethod
    def _xor_encode(
        message: str | bytes, xor_key: bytes, encoding: str = &#34;utf-8&#34;
    ) -&gt; bytes:
        &#34;&#34;&#34;XOR encrypt the given message with the given XOR key&#34;&#34;&#34;
        if isinstance(message, str):
            message = message.encode(encoding=encoding)

        return bytes(
            [
                message_char ^ xor_char
                for message_char, xor_char in zip(message, cycle(xor_key))
            ]
        )

    @staticmethod
    def _xor_decode(cipher_text: str | bytes, xor_key: bytes) -&gt; str:
        &#34;&#34;&#34;XOR decrypt the given cipher text with the given XOR key&#34;&#34;&#34;
        return HllConnection._xor_encode(cipher_text, xor_key).decode(&#34;utf-8&#34;)

    @classmethod
    async def setup(
        cls,
        ip_addr: str,
        port: int,
        password: str,
        receive_timeout: int,
        tcp_timeout: int,
    ) -&gt; Self:
        &#34;&#34;&#34;Create and return an instance after it has connected to the game server&#34;&#34;&#34;
        instance = HllConnection(ip_addr, port, password, receive_timeout, tcp_timeout)
        await instance.connect()
        return instance

    async def _connect(self) -&gt; None:
        &#34;&#34;&#34;Open a socket to the game server and retrieve the XOR key&#34;&#34;&#34;
        with trio.fail_after(self.tcp_timeout):
            self._connection = await trio.open_tcp_stream(self.ip_addr, self.port)

        # The very first thing the game server will return is the XOR key that all
        # subsequent requests require for encoding/decoding
        with trio.fail_after(self.tcp_timeout):
            self.xor_key = await self._receive_from_game_server()

    async def connect(self) -&gt; None:
        &#34;&#34;&#34;Connect to and log into the game server&#34;&#34;&#34;
        await self._connect()
        await self.login()

    async def _receive_from_game_server(
        self,
        max_bytes: int
        | None = constants.CHUNK_SIZE,  # TODO allow configuration for this
        validator: Callable | None = None,
        **kwargs,
    ) -&gt; bytes:
        &#34;&#34;&#34;Accumulate chunks of bytes from the game server and return them

        The game server does not indicate end of blocks of data in any way and does not
        send the empty (b&#34;&#34;) value trio would need to iterate over the connection. Instead
        we repeatedly try to read from the socket until we time out at self.receive_timeout
        seconds and then return all the accumulated data
        &#34;&#34;&#34;

        buffer = bytearray()
        while True:
            try:
                with trio.fail_after(self.receive_timeout):
                    buffer += await self.connection.receive_some(max_bytes)

                    # The game server does not send back any sort of EOF marker
                    # so there is no way to know when we&#39;re actually done, some
                    # return values can be identified as complete and valid return
                    # results, and if so we can return early, otherwise we block
                    # until we time out
                    logger.debug(f&#34;{validator=}&#34;)
                    if validator and validator(
                        self._xor_decode(buffer, self.xor_key), **kwargs
                    ):
                        logger.debug(f&#34;breaking on complete chunk&#34;)
                        break

            except trio.TooSlowError:
                if validator:
                    logger.error(
                        f&#34;Timed out in {id(self)} buffer=`{self._xor_decode(buffer, self.xor_key)}`&#34;
                    )
                    raise
                break

        return bytes(buffer)

    async def _send_to_game_server(
        self,
        content: str,
        response_validator: Callable | None = None,
        retry_attempts: int = 2,
        **kwargs,
    ) -&gt; str:
        &#34;&#34;&#34;XOR the content and send to the game server, returning the game server response&#34;&#34;&#34;
        logger.debug(f&#34;{id(self)} {len(content)=} {content=}&#34;)
        xored_content = HllConnection._xor_encode(content, self.xor_key)
        result = None
        for _ in range(retry_attempts):
            try:
                with trio.fail_after(self.tcp_timeout):
                    logger.debug(f&#34;sending content=`{content}`&#34;)
                    await self.connection.send_all(xored_content)
                    result = await self._receive_from_game_server(
                        validator=response_validator, **kwargs
                    )
                    break
            except (FailedGameServerResponse, trio.TooSlowError) as e:
                logger.error(
                    f&#34;{id(self)} {content=} {len(content)=} Failed attempt #{_+1}/{retry_attempts} {e}&#34;
                )
                continue

        if not result:
            raise FailedGameServerCommand

        logger.warning(f&#34;received {len(result)=} bytes&#34;)

        return HllConnection._xor_decode(result, self.xor_key)

    async def login(self) -&gt; str:
        &#34;&#34;&#34;Log into the game server with the ip/port/password provided during initialization

        Returns:
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Login {self.password}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_server_name(self) -&gt; str:
        &#34;&#34;&#34;Return the server name as defined in the game server `Server.ini` file&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Name&#34;
        return await self._send_to_game_server(content)

    async def get_current_max_player_slots(self) -&gt; str:
        &#34;&#34;&#34;Return the number of players currently on the server and max players in the form X/Y&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Slots&#34;
        return await self._send_to_game_server(content)

    async def get_gamestate(self) -&gt; str:
        &#34;&#34;&#34;Return the current round state

        Returns
            A string, including newlines in the format:

            Players: Allied: 46 - Axis: 46
            Score: Allied: 4 - Axis: 1
            Remaining Time: 0:25:23
            Map: carentan_offensive_ger
            Next Map: hurtgenforest_warfare_V2

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get GameState&#34;
        return await self._send_to_game_server(
            content, response_validator=_gamestate_validator
        )

    async def get_max_queue_size(self) -&gt; str:
        &#34;&#34;&#34;Return the maximum number of players allowed in the queue to join the server&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get MaxQueuedPlayers&#34;
        return await self._send_to_game_server(content)

    async def set_max_queue_size(self, size: int) -&gt; str:
        &#34;&#34;&#34;Set the maximum number of players allowed in the queue to join the server (0 &lt;= size &lt;= 6)

        Returns
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetMaxQueuedPlayers {size}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_num_vip_slots(self) -&gt; str:
        &#34;&#34;&#34;Returns the number of reserved VIP slots&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get NumVipSlots&#34;
        return await self._send_to_game_server(content)

    async def set_num_vip_slots(self, amount: int) -&gt; str:
        &#34;&#34;&#34;Set the number of reserved VIP slots on the server

        For example, setting this to 2 on a 100 slot server would only allow players
        with VIP access to join once 98 players are connected (regardless of those
        players VIP status)

        Returns
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({amount=})&#34;  # type: ignore
        )
        content = f&#34;SetNumVipSlots {amount}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def set_welcome_message(self, message: str) -&gt; str:
        &#34;&#34;&#34;Set the server welcome message

        Returns
            &#34;SUCCESS&#34; or &#34;FAILURE&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({message=})&#34;  # type: ignore
        )
        content = f&#34;Say {message}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def set_broadcast_message(self, message: str | None) -&gt; str:
        &#34;&#34;&#34;Set the current broadcast message, or clear it if message is None

        As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({message=})&#34;  # type: ignore
        )
        if message:
            content = f&#34;Broadcast {message}&#34;
        else:
            raise NotImplementedError
            content = f&#34;Broadcast  &#34;

        logger.debug(f&#34;{content=}&#34;)
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def clear_broadcast_message(self) -&gt; str:
        &#34;&#34;&#34;Clear the current broadcast message

        As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken
        &#34;&#34;&#34;
        raise NotImplementedError
        return await self.set_broadcast_message(None)

    async def get_game_logs(self, minutes: int, filter: str | None = None) -&gt; str:
        &#34;&#34;&#34;Return a new line delimited list of game logs

        Args
            minutes: The number of minutes worth of logs to return, it is not possible to retrieve
                logs after server restarts
            filter: Return only logs that contain this string in them

        Returns
            A string of log lines delimited by new lines, certain log types may contain new lines such as KICKs or MESSAGES
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({minutes=}, {filter=})&#34;  # type: ignore
        )
        if filter is None:
            filter = &#34;&#34;

        content = f&#39;ShowLog {minutes} &#34;{filter}&#34;&#39;
        return await self._send_to_game_server(content)

    async def get_current_map(self) -&gt; str:
        &#34;&#34;&#34;Return the current map name&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Map&#34;
        return await self._send_to_game_server(content)

    async def get_available_maps(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of all available map names.&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get MapsForRotation&#34;
        return await self._send_to_game_server(content)

    async def get_map_rotation(self) -&gt; str:
        &#34;&#34;&#34;Return a newline delimited string of the currently set map rotation names&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;RotList&#34;
        return await self._send_to_game_server(content)

    async def add_map_to_rotation(
        self,
        name: str,
        after_map_name: str | None = None,
        after_map_ordinal: int | None = None,
    ) -&gt; str:
        &#34;&#34;&#34;Add the map to the rotation in the specified spot, appends to the end of the rotation by default

        Returns
            SUCCESS or game server error messages
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;RotAdd {name} {after_map_name or &#39;&#39;} {after_map_ordinal or &#39;&#39;}&#34;
        return await self._send_to_game_server(content)

    async def remove_map_from_rotation(self, name: str, ordinal: int | None = 1) -&gt; str:
        &#34;&#34;&#34;Remove the specified map instance from the rotation

        Returns
            SUCCESS or game server error messages
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;RotDel {name} {ordinal or &#39;&#39;}&#34;
        return await self._send_to_game_server(content)

    async def set_current_map(self, name: str, ordinal: int | None = 1) -&gt; str:
        &#34;&#34;&#34;Immediately change the game server to the map after a 60 second delay, the map must be in the rotation

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Map {name} {ordinal or &#39;&#39;}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_players(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of player names currently connected to the game server&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Players&#34;
        return await self._send_to_game_server(content)

    async def get_player_steam_ids(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of player names and steam IDs in the format player_name : steam_id_64&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get PlayerIds&#34;
        return await self._send_to_game_server(content)

    async def get_admin_ids(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of admins and their roles

        See also get_admin_groups()

        Returns
            tab delimited list in the form: steam_id_64 role &#34;name&#34;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AdminIds&#34;
        return await self._send_to_game_server(content)

    async def get_admin_groups(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of available admin roles&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AdminGroups&#34;
        return await self._send_to_game_server(content)

    async def add_admin(
        self, steam_id_64: str, role: str, name: str | None = None
    ) -&gt; str:
        &#34;&#34;&#34;Grant the specified steam ID the specified role

        Role must be valid, see get_admin_groups()

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;AdminAdd {steam_id_64} {role} {name or &#39;&#39;}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_admin(self, steam_id_64: str) -&gt; str:
        &#34;&#34;&#34;Remove all admin roles from the specified steam ID, see get_admin_groups() for possible admin roles

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;AdminDel {steam_id_64}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_vip_ids(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of VIP steam ID 64s and names&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get VipIds&#34;
        return await self._send_to_game_server(content)

    async def get_player_info(self, player_name: str) -&gt; str:
        &#34;&#34;&#34;Return detailed player info for the given player name

        Returns
            New line delimited string in the form:

            Name: Muller
            steamID64: 76561198148668981
            Team: Axis
            Role: HeavyMachineGunner
            Unit: 2 - CHARLIE
            Loadout: Standard Issue
            Kills: 39 - Deaths: 30
            Score: C 389, O 380, D 920, S 30
            Level: 77

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({player_name=})&#34;  # type: ignore
        )
        content = f&#34;PlayerInfo {player_name}&#34;
        result = await self._send_to_game_server(
            content, _player_info_validator, player_name=player_name, conn_id=id(self)
        )

        logger.debug(f&#34;{id(self)} {result=}&#34;)
        return result

    async def add_vip(self, steam_id_64: str, name: str | None) -&gt; str:
        &#34;&#34;&#34;Grant VIP status to the given steam ID

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;VipAdd {steam_id_64} {name}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_vip(self, steam_id_64: str) -&gt; str:
        &#34;&#34;&#34;Remove VIP status from the given steam ID

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;VipDel {steam_id_64}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_temp_bans(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of temporary ban lists&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get TempBans&#34;
        return await self._send_to_game_server(content)

    async def get_permanent_bans(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of permanent ban lists&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get PermaBans&#34;
        return await self._send_to_game_server(content)

    async def message_player(
        self,
        message: str,
        steam_id_64: str | None = None,
        player_name: str | None = None,
    ) -&gt; str:
        &#34;&#34;&#34;Send an in game message to the specified player

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#39;Message &#34;{steam_id_64 or player_name}&#34; &#34;{message}&#34;&#39;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def punish_player(self, player_name: str, reason: str | None = None) -&gt; str:
        &#34;&#34;&#34;Punish (kill in game) the specified player, will fail if they are not spawned

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Punish {player_name} {reason}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def switch_player_on_death(self, player_name: str) -&gt; str:
        &#34;&#34;&#34;Switch a player to the other team after their next death

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SwitchTeamOnDeath {player_name}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def switch_player_now(self, player_name: str) -&gt; str:
        &#34;&#34;&#34;Immediately switch a player to the other team

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SwitchTeamNow {player_name}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def kick_player(self, player_name: str, reason: str | None = None) -&gt; str:
        &#34;&#34;&#34;Remove a player from the server and show them the indicated reason

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Kick {player_name} {reason}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def temp_ban_player(
        self,
        steam_id_64: str | None = None,
        player_name: str | None = None,
        duration_hours: int | None = None,
        reason: str | None = None,
        by_admin_name: str | None = None,
    ) -&gt; str:
        &#34;&#34;&#34;Ban a player from the server for the given number of hours and show them the indicated reason

        Args
            steam_id_64: optional if player name is provided
            player_name: optional if steam_id_64 is provided, will use steam_id_64 if both are passed
            duration_hours: number of hours to ban, will be cleared on game server restart, defaults to 2 if not provided
            reason: optional reason for the ban that is shown to the player
            by_admin_name: optional name for which admin or automated service banned the player
        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )

        if duration_hours is None:
            validated_duration = &#34;&#34;
        else:
            validated_duration = str(duration_hours)

        if reason is None:
            reason = &#34;&#34;

        if by_admin_name is None:
            by_admin_name = &#34;&#34;

        content = f&#39;TempBan &#34;{steam_id_64 or player_name}&#34; {validated_duration} &#34;{reason}&#34; &#34;{by_admin_name}&#34;&#39;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def perma_ban_player(
        self,
        steam_id_64: str | None = None,
        player_name: str | None = None,
        reason: str | None = None,
        by_admin_name: str | None = None,
    ) -&gt; str:
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        &#34;&#34;&#34;Permanently ban a player and show them the indicated reason

        Args
            steam_id_64: optional if player name is provided
            player_name: optional if steam_id_64 is provided, will use steam_id_64 if both are passed
            reason: optional reason for the ban that is shown to the player
            by_admin_name: optional name for which admin or automated service banned the player

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;

        if reason is None:
            reason = &#34;&#34;

        if by_admin_name is None:
            by_admin_name = &#34;&#34;

        content = (
            f&#39;PermaBan &#34;{steam_id_64 or player_name}&#34; &#34;{reason}&#34; &#34;{by_admin_name}&#34;&#39;
        )
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_temp_ban(self, ban_log: str) -&gt; str:
        &#34;&#34;&#34;Remove a temporary ban from a player

        Args
            ban_log: Must match the HLL ban log format returned from get_temp_bans

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;PardonTempBan {ban_log}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def remove_perma_ban(self, ban_log: str) -&gt; str:
        &#34;&#34;&#34;Remove a permanent ban from a player

        Args
            ban_log: Must match the HLL ban log format returned from get_permanent_bans()

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;PardonPermaBan {ban_log}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_idle_kick_time(self) -&gt; str:
        &#34;&#34;&#34;Return the current idle kick time in minutes&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Idletime&#34;
        return await self._send_to_game_server(content)

    async def set_idle_kick_time(self, threshold_minutes: int) -&gt; str:
        &#34;&#34;&#34;Set the idle kick time in minutes

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetKickIdleTime {threshold_minutes}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_high_ping_limit(self) -&gt; str:
        &#34;&#34;&#34;Return the high ping limit in milliseconds&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get HighPing&#34;
        return await self._send_to_game_server(content)

    async def set_high_ping_limit(self, threshold: int) -&gt; str:
        &#34;&#34;&#34;Set the high ping limit (player is kicked when they exceed) in milliseconds

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetHighPing {threshold}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def disable_high_ping_limit(self) -&gt; str:
        &#34;&#34;&#34;Disable (set to 0) the high ping limit

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        return await self.set_high_ping_limit(0)

    async def get_team_switch_cooldown(self) -&gt; str:
        &#34;&#34;&#34;Return the current team switch cool down in minutes&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get TeamSwitchCooldown&#34;
        return await self._send_to_game_server(content)

    async def set_team_switch_cooldown(self, cooldown: int) -&gt; str:
        &#34;&#34;&#34;Set the team switch cool down in minutes

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetTeamSwitchCooldown {cooldown}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_auto_balance_enabled(self) -&gt; str:
        &#34;&#34;&#34;Return if team auto balance (enforced differences in team sizes) is enabled

        Returns
            &#39;on&#39; or &#39;off&#39;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AutoBalanceEnabled&#34;
        return await self._send_to_game_server(
            content, response_validator=_on_off_validator
        )

    async def enable_auto_balance(self) -&gt; str:
        &#34;&#34;&#34;Enable the team auto balance (enforced differences in team sizes) feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetAutobalanceEnabled {constants.HLL_BOOL_ENABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def disable_auto_balance(self) -&gt; str:
        &#34;&#34;&#34;Disable the team auto balance (enforced differences in team sizes) feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetAutobalanceEnabled {constants.HLL_BOOL_DISABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_auto_balance_threshold(self) -&gt; str:
        &#34;&#34;&#34;Return the allowed team size difference before players are forced to join the other team&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get AutoBalanceThreshold&#34;
        return await self._send_to_game_server(content)

    async def set_auto_balance_threshold(self, threshold: int) -&gt; str:
        &#34;&#34;&#34;Set the allowed team size difference before players are forced to join the other team

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetAutoBalanceThreshold {threshold}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_vote_kick_enabled(self) -&gt; str:
        &#34;&#34;&#34;Return if vote to kick players is enabled

        Returns
            &#39;on&#39; or &#39;off&#39;
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get VoteKickEnabled&#34;
        return await self._send_to_game_server(
            content, response_validator=_on_off_validator
        )

    async def enable_vote_kick(self) -&gt; str:
        &#34;&#34;&#34;Enable the vote to kick players feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;

        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetVoteKickEnabled  {constants.HLL_BOOL_ENABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def disable_vote_kick(self) -&gt; str:
        &#34;&#34;&#34;Disable the vote to kick players feature

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetVoteKickEnabled  {constants.HLL_BOOL_DISABLED}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_vote_kick_thresholds(self) -&gt; str:
        &#34;&#34;&#34;Return the required number of votes to remove from the server in threshold pairs

        Returns
            A comma separated list in the form: players, votes required for instance 0,1,10,5
                means when 10 players are on, 5 votes are required to remove a player
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get VoteKickThreshold&#34;
        return await self._send_to_game_server(content)

    async def set_vote_kick_thresholds(self, threshold_pairs: str) -&gt; str:
        &#34;&#34;&#34;Set vote kick threshold pairs, the first entry must be for 0 players

        Args
            threshold_pairs: A comma separated list in the form: players, votes required for instance 0,1,10,5
                means when 10 players are on, 5 votes are required to remove a player
        Returns
            SUCCESS or FAIL or error message
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;SetVoteKickThreshold {threshold_pairs}&#34;

        # This validator won&#39;t work 100% of the time since this can return error messages
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def clear_vote_kick_threshold(self) -&gt; str:
        &#34;&#34;&#34;Clear vote kick threshold pairs

        Removes all the threshold pairs, the game server does not appear to have defaults

        Returns
            SUCCESS or FAIL
        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;ResetVoteKickThreshold&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def get_censored_words(self) -&gt; str:
        &#34;&#34;&#34;Return a HLL tab delimited list of all words that will be censored in game chat&#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;Get Profanity&#34;
        return await self._send_to_game_server(content)

    async def censor_words(self, words: str) -&gt; str:
        &#34;&#34;&#34;Append a comma delimited list of words to censor in game chat

        Args
            words: Must be a comma separated list, white space between commas is preserved
                and words are appended, adding a word that already exists will return SUCCESS
                but the word will not be duplicated

        Returns
            SUCCESS or FAIL

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;BanProfanity {words}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )

    async def uncensor_words(self, words: str) -&gt; str:
        &#34;&#34;&#34;Remove a comma delimited list of words to censor in game chat

        Args
            words: Must be a comma separated list, response_validator=_success_fail_validator, white space between commas is preserved

        Returns
            SUCCESS or FAIL

        &#34;&#34;&#34;
        logger.debug(
            f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
        )
        content = f&#34;UnbanProfanity {words}&#34;
        return await self._send_to_game_server(
            content, response_validator=_success_fail_validator
        )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="async_hll_rcon.connection.HllConnection.setup"><code class="name flex">
<span>async def <span class="ident">setup</span></span>(<span>ip_addr: str, port: int, password: str, receive_timeout: int, tcp_timeout: int) ‑> Self</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return an instance after it has connected to the game server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def setup(
    cls,
    ip_addr: str,
    port: int,
    password: str,
    receive_timeout: int,
    tcp_timeout: int,
) -&gt; Self:
    &#34;&#34;&#34;Create and return an instance after it has connected to the game server&#34;&#34;&#34;
    instance = HllConnection(ip_addr, port, password, receive_timeout, tcp_timeout)
    await instance.connect()
    return instance</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="async_hll_rcon.connection.HllConnection.connection"><code class="name">var <span class="ident">connection</span> : trio.SocketStream</code></dt>
<dd>
<div class="desc"><p>Safety check to make sure an unconnected instance isn't used</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def connection(self) -&gt; trio.SocketStream:
    &#34;&#34;&#34;Safety check to make sure an unconnected instance isn&#39;t used&#34;&#34;&#34;
    if self._connection is not None:
        return self._connection
    else:
        raise ValueError(&#34;Socket connection to the game server not established.&#34;)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.receive_timeout"><code class="name">var <span class="ident">receive_timeout</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def receive_timeout(self) -&gt; float:
    return self._receive_timeout</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.tcp_timeout"><code class="name">var <span class="ident">tcp_timeout</span> : float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tcp_timeout(self) -&gt; float:
    return self._tcp_timeout</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="async_hll_rcon.connection.HllConnection.add_admin"><code class="name flex">
<span>async def <span class="ident">add_admin</span></span>(<span>self, steam_id_64: str, role: str, name: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Grant the specified steam ID the specified role</p>
<p>Role must be valid, see get_admin_groups()</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_admin(
    self, steam_id_64: str, role: str, name: str | None = None
) -&gt; str:
    &#34;&#34;&#34;Grant the specified steam ID the specified role

    Role must be valid, see get_admin_groups()

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;AdminAdd {steam_id_64} {role} {name or &#39;&#39;}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.add_map_to_rotation"><code class="name flex">
<span>async def <span class="ident">add_map_to_rotation</span></span>(<span>self, name: str, after_map_name: str | None = None, after_map_ordinal: int | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Add the map to the rotation in the specified spot, appends to the end of the rotation by default</p>
<p>Returns
SUCCESS or game server error messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_map_to_rotation(
    self,
    name: str,
    after_map_name: str | None = None,
    after_map_ordinal: int | None = None,
) -&gt; str:
    &#34;&#34;&#34;Add the map to the rotation in the specified spot, appends to the end of the rotation by default

    Returns
        SUCCESS or game server error messages
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;RotAdd {name} {after_map_name or &#39;&#39;} {after_map_ordinal or &#39;&#39;}&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.add_vip"><code class="name flex">
<span>async def <span class="ident">add_vip</span></span>(<span>self, steam_id_64: str, name: str | None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Grant VIP status to the given steam ID</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def add_vip(self, steam_id_64: str, name: str | None) -&gt; str:
    &#34;&#34;&#34;Grant VIP status to the given steam ID

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;VipAdd {steam_id_64} {name}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.censor_words"><code class="name flex">
<span>async def <span class="ident">censor_words</span></span>(<span>self, words: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Append a comma delimited list of words to censor in game chat</p>
<p>Args
words: Must be a comma separated list, white space between commas is preserved
and words are appended, adding a word that already exists will return SUCCESS
but the word will not be duplicated</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def censor_words(self, words: str) -&gt; str:
    &#34;&#34;&#34;Append a comma delimited list of words to censor in game chat

    Args
        words: Must be a comma separated list, white space between commas is preserved
            and words are appended, adding a word that already exists will return SUCCESS
            but the word will not be duplicated

    Returns
        SUCCESS or FAIL

    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;BanProfanity {words}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.clear_broadcast_message"><code class="name flex">
<span>async def <span class="ident">clear_broadcast_message</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Clear the current broadcast message</p>
<p>As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_broadcast_message(self) -&gt; str:
    &#34;&#34;&#34;Clear the current broadcast message

    As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken
    &#34;&#34;&#34;
    raise NotImplementedError
    return await self.set_broadcast_message(None)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.clear_vote_kick_threshold"><code class="name flex">
<span>async def <span class="ident">clear_vote_kick_threshold</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Clear vote kick threshold pairs</p>
<p>Removes all the threshold pairs, the game server does not appear to have defaults</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def clear_vote_kick_threshold(self) -&gt; str:
    &#34;&#34;&#34;Clear vote kick threshold pairs

    Removes all the threshold pairs, the game server does not appear to have defaults

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;ResetVoteKickThreshold&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.connect"><code class="name flex">
<span>async def <span class="ident">connect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to and log into the game server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def connect(self) -&gt; None:
    &#34;&#34;&#34;Connect to and log into the game server&#34;&#34;&#34;
    await self._connect()
    await self.login()</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.disable_auto_balance"><code class="name flex">
<span>async def <span class="ident">disable_auto_balance</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Disable the team auto balance (enforced differences in team sizes) feature</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disable_auto_balance(self) -&gt; str:
    &#34;&#34;&#34;Disable the team auto balance (enforced differences in team sizes) feature

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetAutobalanceEnabled {constants.HLL_BOOL_DISABLED}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.disable_high_ping_limit"><code class="name flex">
<span>async def <span class="ident">disable_high_ping_limit</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Disable (set to 0) the high ping limit</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disable_high_ping_limit(self) -&gt; str:
    &#34;&#34;&#34;Disable (set to 0) the high ping limit

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    return await self.set_high_ping_limit(0)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.disable_vote_kick"><code class="name flex">
<span>async def <span class="ident">disable_vote_kick</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Disable the vote to kick players feature</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def disable_vote_kick(self) -&gt; str:
    &#34;&#34;&#34;Disable the vote to kick players feature

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetVoteKickEnabled  {constants.HLL_BOOL_DISABLED}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.enable_auto_balance"><code class="name flex">
<span>async def <span class="ident">enable_auto_balance</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the team auto balance (enforced differences in team sizes) feature</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def enable_auto_balance(self) -&gt; str:
    &#34;&#34;&#34;Enable the team auto balance (enforced differences in team sizes) feature

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetAutobalanceEnabled {constants.HLL_BOOL_ENABLED}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.enable_vote_kick"><code class="name flex">
<span>async def <span class="ident">enable_vote_kick</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the vote to kick players feature</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def enable_vote_kick(self) -&gt; str:
    &#34;&#34;&#34;Enable the vote to kick players feature

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;

    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetVoteKickEnabled  {constants.HLL_BOOL_ENABLED}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_admin_groups"><code class="name flex">
<span>async def <span class="ident">get_admin_groups</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of available admin roles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_admin_groups(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of available admin roles&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get AdminGroups&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_admin_ids"><code class="name flex">
<span>async def <span class="ident">get_admin_ids</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of admins and their roles</p>
<p>See also get_admin_groups()</p>
<p>Returns
tab delimited list in the form: steam_id_64 role "name"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_admin_ids(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of admins and their roles

    See also get_admin_groups()

    Returns
        tab delimited list in the form: steam_id_64 role &#34;name&#34;
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get AdminIds&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_auto_balance_enabled"><code class="name flex">
<span>async def <span class="ident">get_auto_balance_enabled</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return if team auto balance (enforced differences in team sizes) is enabled</p>
<p>Returns
'on' or 'off'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_auto_balance_enabled(self) -&gt; str:
    &#34;&#34;&#34;Return if team auto balance (enforced differences in team sizes) is enabled

    Returns
        &#39;on&#39; or &#39;off&#39;
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get AutoBalanceEnabled&#34;
    return await self._send_to_game_server(
        content, response_validator=_on_off_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_auto_balance_threshold"><code class="name flex">
<span>async def <span class="ident">get_auto_balance_threshold</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the allowed team size difference before players are forced to join the other team</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_auto_balance_threshold(self) -&gt; str:
    &#34;&#34;&#34;Return the allowed team size difference before players are forced to join the other team&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get AutoBalanceThreshold&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_available_maps"><code class="name flex">
<span>async def <span class="ident">get_available_maps</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of all available map names.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_available_maps(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of all available map names.&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get MapsForRotation&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_censored_words"><code class="name flex">
<span>async def <span class="ident">get_censored_words</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of all words that will be censored in game chat</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_censored_words(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of all words that will be censored in game chat&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get Profanity&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_current_map"><code class="name flex">
<span>async def <span class="ident">get_current_map</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current map name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_current_map(self) -&gt; str:
    &#34;&#34;&#34;Return the current map name&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get Map&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_current_max_player_slots"><code class="name flex">
<span>async def <span class="ident">get_current_max_player_slots</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of players currently on the server and max players in the form X/Y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_current_max_player_slots(self) -&gt; str:
    &#34;&#34;&#34;Return the number of players currently on the server and max players in the form X/Y&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get Slots&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_game_logs"><code class="name flex">
<span>async def <span class="ident">get_game_logs</span></span>(<span>self, minutes: int, filter: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new line delimited list of game logs</p>
<p>Args
minutes: The number of minutes worth of logs to return, it is not possible to retrieve
logs after server restarts
filter: Return only logs that contain this string in them</p>
<p>Returns
A string of log lines delimited by new lines, certain log types may contain new lines such as KICKs or MESSAGES</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_game_logs(self, minutes: int, filter: str | None = None) -&gt; str:
    &#34;&#34;&#34;Return a new line delimited list of game logs

    Args
        minutes: The number of minutes worth of logs to return, it is not possible to retrieve
            logs after server restarts
        filter: Return only logs that contain this string in them

    Returns
        A string of log lines delimited by new lines, certain log types may contain new lines such as KICKs or MESSAGES
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({minutes=}, {filter=})&#34;  # type: ignore
    )
    if filter is None:
        filter = &#34;&#34;

    content = f&#39;ShowLog {minutes} &#34;{filter}&#34;&#39;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_gamestate"><code class="name flex">
<span>async def <span class="ident">get_gamestate</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current round state</p>
<p>Returns
A string, including newlines in the format:</p>
<pre><code>Players: Allied: 46 - Axis: 46
Score: Allied: 4 - Axis: 1
Remaining Time: 0:25:23
Map: carentan_offensive_ger
Next Map: hurtgenforest_warfare_V2
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_gamestate(self) -&gt; str:
    &#34;&#34;&#34;Return the current round state

    Returns
        A string, including newlines in the format:

        Players: Allied: 46 - Axis: 46
        Score: Allied: 4 - Axis: 1
        Remaining Time: 0:25:23
        Map: carentan_offensive_ger
        Next Map: hurtgenforest_warfare_V2

    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get GameState&#34;
    return await self._send_to_game_server(
        content, response_validator=_gamestate_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_high_ping_limit"><code class="name flex">
<span>async def <span class="ident">get_high_ping_limit</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the high ping limit in milliseconds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_high_ping_limit(self) -&gt; str:
    &#34;&#34;&#34;Return the high ping limit in milliseconds&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get HighPing&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_idle_kick_time"><code class="name flex">
<span>async def <span class="ident">get_idle_kick_time</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current idle kick time in minutes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_idle_kick_time(self) -&gt; str:
    &#34;&#34;&#34;Return the current idle kick time in minutes&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get Idletime&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_map_rotation"><code class="name flex">
<span>async def <span class="ident">get_map_rotation</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a newline delimited string of the currently set map rotation names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_map_rotation(self) -&gt; str:
    &#34;&#34;&#34;Return a newline delimited string of the currently set map rotation names&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;RotList&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_max_queue_size"><code class="name flex">
<span>async def <span class="ident">get_max_queue_size</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the maximum number of players allowed in the queue to join the server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_max_queue_size(self) -&gt; str:
    &#34;&#34;&#34;Return the maximum number of players allowed in the queue to join the server&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get MaxQueuedPlayers&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_num_vip_slots"><code class="name flex">
<span>async def <span class="ident">get_num_vip_slots</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of reserved VIP slots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_num_vip_slots(self) -&gt; str:
    &#34;&#34;&#34;Returns the number of reserved VIP slots&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get NumVipSlots&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_permanent_bans"><code class="name flex">
<span>async def <span class="ident">get_permanent_bans</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of permanent ban lists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_permanent_bans(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of permanent ban lists&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get PermaBans&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_player_info"><code class="name flex">
<span>async def <span class="ident">get_player_info</span></span>(<span>self, player_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return detailed player info for the given player name</p>
<p>Returns
New line delimited string in the form:</p>
<pre><code>Name: Muller
steamID64: 76561198148668981
Team: Axis
Role: HeavyMachineGunner
Unit: 2 - CHARLIE
Loadout: Standard Issue
Kills: 39 - Deaths: 30
Score: C 389, O 380, D 920, S 30
Level: 77
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_player_info(self, player_name: str) -&gt; str:
    &#34;&#34;&#34;Return detailed player info for the given player name

    Returns
        New line delimited string in the form:

        Name: Muller
        steamID64: 76561198148668981
        Team: Axis
        Role: HeavyMachineGunner
        Unit: 2 - CHARLIE
        Loadout: Standard Issue
        Kills: 39 - Deaths: 30
        Score: C 389, O 380, D 920, S 30
        Level: 77

    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({player_name=})&#34;  # type: ignore
    )
    content = f&#34;PlayerInfo {player_name}&#34;
    result = await self._send_to_game_server(
        content, _player_info_validator, player_name=player_name, conn_id=id(self)
    )

    logger.debug(f&#34;{id(self)} {result=}&#34;)
    return result</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_player_steam_ids"><code class="name flex">
<span>async def <span class="ident">get_player_steam_ids</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of player names and steam IDs in the format player_name : steam_id_64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_player_steam_ids(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of player names and steam IDs in the format player_name : steam_id_64&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get PlayerIds&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_players"><code class="name flex">
<span>async def <span class="ident">get_players</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of player names currently connected to the game server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_players(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of player names currently connected to the game server&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get Players&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_server_name"><code class="name flex">
<span>async def <span class="ident">get_server_name</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the server name as defined in the game server <code>Server.ini</code> file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_server_name(self) -&gt; str:
    &#34;&#34;&#34;Return the server name as defined in the game server `Server.ini` file&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get Name&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_team_switch_cooldown"><code class="name flex">
<span>async def <span class="ident">get_team_switch_cooldown</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current team switch cool down in minutes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_team_switch_cooldown(self) -&gt; str:
    &#34;&#34;&#34;Return the current team switch cool down in minutes&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get TeamSwitchCooldown&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_temp_bans"><code class="name flex">
<span>async def <span class="ident">get_temp_bans</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of temporary ban lists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_temp_bans(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of temporary ban lists&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get TempBans&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_vip_ids"><code class="name flex">
<span>async def <span class="ident">get_vip_ids</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return a HLL tab delimited list of VIP steam ID 64s and names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_vip_ids(self) -&gt; str:
    &#34;&#34;&#34;Return a HLL tab delimited list of VIP steam ID 64s and names&#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get VipIds&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_vote_kick_enabled"><code class="name flex">
<span>async def <span class="ident">get_vote_kick_enabled</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return if vote to kick players is enabled</p>
<p>Returns
'on' or 'off'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_vote_kick_enabled(self) -&gt; str:
    &#34;&#34;&#34;Return if vote to kick players is enabled

    Returns
        &#39;on&#39; or &#39;off&#39;
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get VoteKickEnabled&#34;
    return await self._send_to_game_server(
        content, response_validator=_on_off_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.get_vote_kick_thresholds"><code class="name flex">
<span>async def <span class="ident">get_vote_kick_thresholds</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the required number of votes to remove from the server in threshold pairs</p>
<p>Returns
A comma separated list in the form: players, votes required for instance 0,1,10,5
means when 10 players are on, 5 votes are required to remove a player</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def get_vote_kick_thresholds(self) -&gt; str:
    &#34;&#34;&#34;Return the required number of votes to remove from the server in threshold pairs

    Returns
        A comma separated list in the form: players, votes required for instance 0,1,10,5
            means when 10 players are on, 5 votes are required to remove a player
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Get VoteKickThreshold&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.kick_player"><code class="name flex">
<span>async def <span class="ident">kick_player</span></span>(<span>self, player_name: str, reason: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a player from the server and show them the indicated reason</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def kick_player(self, player_name: str, reason: str | None = None) -&gt; str:
    &#34;&#34;&#34;Remove a player from the server and show them the indicated reason

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Kick {player_name} {reason}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.login"><code class="name flex">
<span>async def <span class="ident">login</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Log into the game server with the ip/port/password provided during initialization</p>
<h2 id="returns">Returns</h2>
<p>"SUCCESS" or "FAILURE"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def login(self) -&gt; str:
    &#34;&#34;&#34;Log into the game server with the ip/port/password provided during initialization

    Returns:
        &#34;SUCCESS&#34; or &#34;FAILURE&#34;
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Login {self.password}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.message_player"><code class="name flex">
<span>async def <span class="ident">message_player</span></span>(<span>self, message: str, steam_id_64: str | None = None, player_name: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Send an in game message to the specified player</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def message_player(
    self,
    message: str,
    steam_id_64: str | None = None,
    player_name: str | None = None,
) -&gt; str:
    &#34;&#34;&#34;Send an in game message to the specified player

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#39;Message &#34;{steam_id_64 or player_name}&#34; &#34;{message}&#34;&#39;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.perma_ban_player"><code class="name flex">
<span>async def <span class="ident">perma_ban_player</span></span>(<span>self, steam_id_64: str | None = None, player_name: str | None = None, reason: str | None = None, by_admin_name: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def perma_ban_player(
    self,
    steam_id_64: str | None = None,
    player_name: str | None = None,
    reason: str | None = None,
    by_admin_name: str | None = None,
) -&gt; str:
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    &#34;&#34;&#34;Permanently ban a player and show them the indicated reason

    Args
        steam_id_64: optional if player name is provided
        player_name: optional if steam_id_64 is provided, will use steam_id_64 if both are passed
        reason: optional reason for the ban that is shown to the player
        by_admin_name: optional name for which admin or automated service banned the player

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;

    if reason is None:
        reason = &#34;&#34;

    if by_admin_name is None:
        by_admin_name = &#34;&#34;

    content = (
        f&#39;PermaBan &#34;{steam_id_64 or player_name}&#34; &#34;{reason}&#34; &#34;{by_admin_name}&#34;&#39;
    )
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.punish_player"><code class="name flex">
<span>async def <span class="ident">punish_player</span></span>(<span>self, player_name: str, reason: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Punish (kill in game) the specified player, will fail if they are not spawned</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def punish_player(self, player_name: str, reason: str | None = None) -&gt; str:
    &#34;&#34;&#34;Punish (kill in game) the specified player, will fail if they are not spawned

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Punish {player_name} {reason}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.remove_admin"><code class="name flex">
<span>async def <span class="ident">remove_admin</span></span>(<span>self, steam_id_64: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all admin roles from the specified steam ID, see get_admin_groups() for possible admin roles</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remove_admin(self, steam_id_64: str) -&gt; str:
    &#34;&#34;&#34;Remove all admin roles from the specified steam ID, see get_admin_groups() for possible admin roles

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;AdminDel {steam_id_64}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.remove_map_from_rotation"><code class="name flex">
<span>async def <span class="ident">remove_map_from_rotation</span></span>(<span>self, name: str, ordinal: int | None = 1) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the specified map instance from the rotation</p>
<p>Returns
SUCCESS or game server error messages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remove_map_from_rotation(self, name: str, ordinal: int | None = 1) -&gt; str:
    &#34;&#34;&#34;Remove the specified map instance from the rotation

    Returns
        SUCCESS or game server error messages
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;RotDel {name} {ordinal or &#39;&#39;}&#34;
    return await self._send_to_game_server(content)</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.remove_perma_ban"><code class="name flex">
<span>async def <span class="ident">remove_perma_ban</span></span>(<span>self, ban_log: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a permanent ban from a player</p>
<p>Args
ban_log: Must match the HLL ban log format returned from get_permanent_bans()</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remove_perma_ban(self, ban_log: str) -&gt; str:
    &#34;&#34;&#34;Remove a permanent ban from a player

    Args
        ban_log: Must match the HLL ban log format returned from get_permanent_bans()

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;PardonPermaBan {ban_log}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.remove_temp_ban"><code class="name flex">
<span>async def <span class="ident">remove_temp_ban</span></span>(<span>self, ban_log: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a temporary ban from a player</p>
<p>Args
ban_log: Must match the HLL ban log format returned from get_temp_bans</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remove_temp_ban(self, ban_log: str) -&gt; str:
    &#34;&#34;&#34;Remove a temporary ban from a player

    Args
        ban_log: Must match the HLL ban log format returned from get_temp_bans

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;PardonTempBan {ban_log}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.remove_vip"><code class="name flex">
<span>async def <span class="ident">remove_vip</span></span>(<span>self, steam_id_64: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove VIP status from the given steam ID</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def remove_vip(self, steam_id_64: str) -&gt; str:
    &#34;&#34;&#34;Remove VIP status from the given steam ID

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;VipDel {steam_id_64}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_auto_balance_threshold"><code class="name flex">
<span>async def <span class="ident">set_auto_balance_threshold</span></span>(<span>self, threshold: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the allowed team size difference before players are forced to join the other team</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_auto_balance_threshold(self, threshold: int) -&gt; str:
    &#34;&#34;&#34;Set the allowed team size difference before players are forced to join the other team

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetAutoBalanceThreshold {threshold}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_broadcast_message"><code class="name flex">
<span>async def <span class="ident">set_broadcast_message</span></span>(<span>self, message: str | None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current broadcast message, or clear it if message is None</p>
<p>As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_broadcast_message(self, message: str | None) -&gt; str:
    &#34;&#34;&#34;Set the current broadcast message, or clear it if message is None

    As of HLL v1.13.0.815373 resetting the broadcast message outside of the in game console is broken
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({message=})&#34;  # type: ignore
    )
    if message:
        content = f&#34;Broadcast {message}&#34;
    else:
        raise NotImplementedError
        content = f&#34;Broadcast  &#34;

    logger.debug(f&#34;{content=}&#34;)
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_current_map"><code class="name flex">
<span>async def <span class="ident">set_current_map</span></span>(<span>self, name: str, ordinal: int | None = 1) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Immediately change the game server to the map after a 60 second delay, the map must be in the rotation</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_current_map(self, name: str, ordinal: int | None = 1) -&gt; str:
    &#34;&#34;&#34;Immediately change the game server to the map after a 60 second delay, the map must be in the rotation

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;Map {name} {ordinal or &#39;&#39;}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_high_ping_limit"><code class="name flex">
<span>async def <span class="ident">set_high_ping_limit</span></span>(<span>self, threshold: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the high ping limit (player is kicked when they exceed) in milliseconds</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_high_ping_limit(self, threshold: int) -&gt; str:
    &#34;&#34;&#34;Set the high ping limit (player is kicked when they exceed) in milliseconds

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetHighPing {threshold}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_idle_kick_time"><code class="name flex">
<span>async def <span class="ident">set_idle_kick_time</span></span>(<span>self, threshold_minutes: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the idle kick time in minutes</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_idle_kick_time(self, threshold_minutes: int) -&gt; str:
    &#34;&#34;&#34;Set the idle kick time in minutes

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetKickIdleTime {threshold_minutes}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_max_queue_size"><code class="name flex">
<span>async def <span class="ident">set_max_queue_size</span></span>(<span>self, size: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the maximum number of players allowed in the queue to join the server (0 &lt;= size &lt;= 6)</p>
<p>Returns
"SUCCESS" or "FAILURE"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_max_queue_size(self, size: int) -&gt; str:
    &#34;&#34;&#34;Set the maximum number of players allowed in the queue to join the server (0 &lt;= size &lt;= 6)

    Returns
        &#34;SUCCESS&#34; or &#34;FAILURE&#34;
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetMaxQueuedPlayers {size}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_num_vip_slots"><code class="name flex">
<span>async def <span class="ident">set_num_vip_slots</span></span>(<span>self, amount: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the number of reserved VIP slots on the server</p>
<p>For example, setting this to 2 on a 100 slot server would only allow players
with VIP access to join once 98 players are connected (regardless of those
players VIP status)</p>
<p>Returns
"SUCCESS" or "FAILURE"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_num_vip_slots(self, amount: int) -&gt; str:
    &#34;&#34;&#34;Set the number of reserved VIP slots on the server

    For example, setting this to 2 on a 100 slot server would only allow players
    with VIP access to join once 98 players are connected (regardless of those
    players VIP status)

    Returns
        &#34;SUCCESS&#34; or &#34;FAILURE&#34;
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({amount=})&#34;  # type: ignore
    )
    content = f&#34;SetNumVipSlots {amount}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_team_switch_cooldown"><code class="name flex">
<span>async def <span class="ident">set_team_switch_cooldown</span></span>(<span>self, cooldown: int) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the team switch cool down in minutes</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_team_switch_cooldown(self, cooldown: int) -&gt; str:
    &#34;&#34;&#34;Set the team switch cool down in minutes

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetTeamSwitchCooldown {cooldown}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_vote_kick_thresholds"><code class="name flex">
<span>async def <span class="ident">set_vote_kick_thresholds</span></span>(<span>self, threshold_pairs: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set vote kick threshold pairs, the first entry must be for 0 players</p>
<p>Args
threshold_pairs: A comma separated list in the form: players, votes required for instance 0,1,10,5
means when 10 players are on, 5 votes are required to remove a player
Returns
SUCCESS or FAIL or error message</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_vote_kick_thresholds(self, threshold_pairs: str) -&gt; str:
    &#34;&#34;&#34;Set vote kick threshold pairs, the first entry must be for 0 players

    Args
        threshold_pairs: A comma separated list in the form: players, votes required for instance 0,1,10,5
            means when 10 players are on, 5 votes are required to remove a player
    Returns
        SUCCESS or FAIL or error message
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SetVoteKickThreshold {threshold_pairs}&#34;

    # This validator won&#39;t work 100% of the time since this can return error messages
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.set_welcome_message"><code class="name flex">
<span>async def <span class="ident">set_welcome_message</span></span>(<span>self, message: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Set the server welcome message</p>
<p>Returns
"SUCCESS" or "FAILURE"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def set_welcome_message(self, message: str) -&gt; str:
    &#34;&#34;&#34;Set the server welcome message

    Returns
        &#34;SUCCESS&#34; or &#34;FAILURE&#34;
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}({message=})&#34;  # type: ignore
    )
    content = f&#34;Say {message}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.switch_player_now"><code class="name flex">
<span>async def <span class="ident">switch_player_now</span></span>(<span>self, player_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Immediately switch a player to the other team</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def switch_player_now(self, player_name: str) -&gt; str:
    &#34;&#34;&#34;Immediately switch a player to the other team

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SwitchTeamNow {player_name}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.switch_player_on_death"><code class="name flex">
<span>async def <span class="ident">switch_player_on_death</span></span>(<span>self, player_name: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Switch a player to the other team after their next death</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def switch_player_on_death(self, player_name: str) -&gt; str:
    &#34;&#34;&#34;Switch a player to the other team after their next death

    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;SwitchTeamOnDeath {player_name}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.temp_ban_player"><code class="name flex">
<span>async def <span class="ident">temp_ban_player</span></span>(<span>self, steam_id_64: str | None = None, player_name: str | None = None, duration_hours: int | None = None, reason: str | None = None, by_admin_name: str | None = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Ban a player from the server for the given number of hours and show them the indicated reason</p>
<p>Args
steam_id_64: optional if player name is provided
player_name: optional if steam_id_64 is provided, will use steam_id_64 if both are passed
duration_hours: number of hours to ban, will be cleared on game server restart, defaults to 2 if not provided
reason: optional reason for the ban that is shown to the player
by_admin_name: optional name for which admin or automated service banned the player
Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def temp_ban_player(
    self,
    steam_id_64: str | None = None,
    player_name: str | None = None,
    duration_hours: int | None = None,
    reason: str | None = None,
    by_admin_name: str | None = None,
) -&gt; str:
    &#34;&#34;&#34;Ban a player from the server for the given number of hours and show them the indicated reason

    Args
        steam_id_64: optional if player name is provided
        player_name: optional if steam_id_64 is provided, will use steam_id_64 if both are passed
        duration_hours: number of hours to ban, will be cleared on game server restart, defaults to 2 if not provided
        reason: optional reason for the ban that is shown to the player
        by_admin_name: optional name for which admin or automated service banned the player
    Returns
        SUCCESS or FAIL
    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )

    if duration_hours is None:
        validated_duration = &#34;&#34;
    else:
        validated_duration = str(duration_hours)

    if reason is None:
        reason = &#34;&#34;

    if by_admin_name is None:
        by_admin_name = &#34;&#34;

    content = f&#39;TempBan &#34;{steam_id_64 or player_name}&#34; {validated_duration} &#34;{reason}&#34; &#34;{by_admin_name}&#34;&#39;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
<dt id="async_hll_rcon.connection.HllConnection.uncensor_words"><code class="name flex">
<span>async def <span class="ident">uncensor_words</span></span>(<span>self, words: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove a comma delimited list of words to censor in game chat</p>
<p>Args
words: Must be a comma separated list, response_validator=_success_fail_validator, white space between commas is preserved</p>
<p>Returns
SUCCESS or FAIL</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def uncensor_words(self, words: str) -&gt; str:
    &#34;&#34;&#34;Remove a comma delimited list of words to censor in game chat

    Args
        words: Must be a comma separated list, response_validator=_success_fail_validator, white space between commas is preserved

    Returns
        SUCCESS or FAIL

    &#34;&#34;&#34;
    logger.debug(
        f&#34;{id(self)} {self.__class__.__name__}.{inspect.getframeinfo(inspect.currentframe()).function}()&#34;  # type: ignore
    )
    content = f&#34;UnbanProfanity {words}&#34;
    return await self._send_to_game_server(
        content, response_validator=_success_fail_validator
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="async_hll_rcon" href="index.html">async_hll_rcon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="async_hll_rcon.connection.HllConnection" href="#async_hll_rcon.connection.HllConnection">HllConnection</a></code></h4>
<ul class="">
<li><code><a title="async_hll_rcon.connection.HllConnection.add_admin" href="#async_hll_rcon.connection.HllConnection.add_admin">add_admin</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.add_map_to_rotation" href="#async_hll_rcon.connection.HllConnection.add_map_to_rotation">add_map_to_rotation</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.add_vip" href="#async_hll_rcon.connection.HllConnection.add_vip">add_vip</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.censor_words" href="#async_hll_rcon.connection.HllConnection.censor_words">censor_words</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.clear_broadcast_message" href="#async_hll_rcon.connection.HllConnection.clear_broadcast_message">clear_broadcast_message</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.clear_vote_kick_threshold" href="#async_hll_rcon.connection.HllConnection.clear_vote_kick_threshold">clear_vote_kick_threshold</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.connect" href="#async_hll_rcon.connection.HllConnection.connect">connect</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.connection" href="#async_hll_rcon.connection.HllConnection.connection">connection</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.disable_auto_balance" href="#async_hll_rcon.connection.HllConnection.disable_auto_balance">disable_auto_balance</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.disable_high_ping_limit" href="#async_hll_rcon.connection.HllConnection.disable_high_ping_limit">disable_high_ping_limit</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.disable_vote_kick" href="#async_hll_rcon.connection.HllConnection.disable_vote_kick">disable_vote_kick</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.enable_auto_balance" href="#async_hll_rcon.connection.HllConnection.enable_auto_balance">enable_auto_balance</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.enable_vote_kick" href="#async_hll_rcon.connection.HllConnection.enable_vote_kick">enable_vote_kick</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_admin_groups" href="#async_hll_rcon.connection.HllConnection.get_admin_groups">get_admin_groups</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_admin_ids" href="#async_hll_rcon.connection.HllConnection.get_admin_ids">get_admin_ids</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_auto_balance_enabled" href="#async_hll_rcon.connection.HllConnection.get_auto_balance_enabled">get_auto_balance_enabled</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_auto_balance_threshold" href="#async_hll_rcon.connection.HllConnection.get_auto_balance_threshold">get_auto_balance_threshold</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_available_maps" href="#async_hll_rcon.connection.HllConnection.get_available_maps">get_available_maps</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_censored_words" href="#async_hll_rcon.connection.HllConnection.get_censored_words">get_censored_words</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_current_map" href="#async_hll_rcon.connection.HllConnection.get_current_map">get_current_map</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_current_max_player_slots" href="#async_hll_rcon.connection.HllConnection.get_current_max_player_slots">get_current_max_player_slots</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_game_logs" href="#async_hll_rcon.connection.HllConnection.get_game_logs">get_game_logs</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_gamestate" href="#async_hll_rcon.connection.HllConnection.get_gamestate">get_gamestate</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_high_ping_limit" href="#async_hll_rcon.connection.HllConnection.get_high_ping_limit">get_high_ping_limit</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_idle_kick_time" href="#async_hll_rcon.connection.HllConnection.get_idle_kick_time">get_idle_kick_time</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_map_rotation" href="#async_hll_rcon.connection.HllConnection.get_map_rotation">get_map_rotation</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_max_queue_size" href="#async_hll_rcon.connection.HllConnection.get_max_queue_size">get_max_queue_size</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_num_vip_slots" href="#async_hll_rcon.connection.HllConnection.get_num_vip_slots">get_num_vip_slots</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_permanent_bans" href="#async_hll_rcon.connection.HllConnection.get_permanent_bans">get_permanent_bans</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_player_info" href="#async_hll_rcon.connection.HllConnection.get_player_info">get_player_info</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_player_steam_ids" href="#async_hll_rcon.connection.HllConnection.get_player_steam_ids">get_player_steam_ids</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_players" href="#async_hll_rcon.connection.HllConnection.get_players">get_players</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_server_name" href="#async_hll_rcon.connection.HllConnection.get_server_name">get_server_name</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_team_switch_cooldown" href="#async_hll_rcon.connection.HllConnection.get_team_switch_cooldown">get_team_switch_cooldown</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_temp_bans" href="#async_hll_rcon.connection.HllConnection.get_temp_bans">get_temp_bans</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_vip_ids" href="#async_hll_rcon.connection.HllConnection.get_vip_ids">get_vip_ids</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_vote_kick_enabled" href="#async_hll_rcon.connection.HllConnection.get_vote_kick_enabled">get_vote_kick_enabled</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.get_vote_kick_thresholds" href="#async_hll_rcon.connection.HllConnection.get_vote_kick_thresholds">get_vote_kick_thresholds</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.kick_player" href="#async_hll_rcon.connection.HllConnection.kick_player">kick_player</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.login" href="#async_hll_rcon.connection.HllConnection.login">login</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.message_player" href="#async_hll_rcon.connection.HllConnection.message_player">message_player</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.perma_ban_player" href="#async_hll_rcon.connection.HllConnection.perma_ban_player">perma_ban_player</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.punish_player" href="#async_hll_rcon.connection.HllConnection.punish_player">punish_player</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.receive_timeout" href="#async_hll_rcon.connection.HllConnection.receive_timeout">receive_timeout</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.remove_admin" href="#async_hll_rcon.connection.HllConnection.remove_admin">remove_admin</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.remove_map_from_rotation" href="#async_hll_rcon.connection.HllConnection.remove_map_from_rotation">remove_map_from_rotation</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.remove_perma_ban" href="#async_hll_rcon.connection.HllConnection.remove_perma_ban">remove_perma_ban</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.remove_temp_ban" href="#async_hll_rcon.connection.HllConnection.remove_temp_ban">remove_temp_ban</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.remove_vip" href="#async_hll_rcon.connection.HllConnection.remove_vip">remove_vip</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_auto_balance_threshold" href="#async_hll_rcon.connection.HllConnection.set_auto_balance_threshold">set_auto_balance_threshold</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_broadcast_message" href="#async_hll_rcon.connection.HllConnection.set_broadcast_message">set_broadcast_message</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_current_map" href="#async_hll_rcon.connection.HllConnection.set_current_map">set_current_map</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_high_ping_limit" href="#async_hll_rcon.connection.HllConnection.set_high_ping_limit">set_high_ping_limit</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_idle_kick_time" href="#async_hll_rcon.connection.HllConnection.set_idle_kick_time">set_idle_kick_time</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_max_queue_size" href="#async_hll_rcon.connection.HllConnection.set_max_queue_size">set_max_queue_size</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_num_vip_slots" href="#async_hll_rcon.connection.HllConnection.set_num_vip_slots">set_num_vip_slots</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_team_switch_cooldown" href="#async_hll_rcon.connection.HllConnection.set_team_switch_cooldown">set_team_switch_cooldown</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_vote_kick_thresholds" href="#async_hll_rcon.connection.HllConnection.set_vote_kick_thresholds">set_vote_kick_thresholds</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.set_welcome_message" href="#async_hll_rcon.connection.HllConnection.set_welcome_message">set_welcome_message</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.setup" href="#async_hll_rcon.connection.HllConnection.setup">setup</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.switch_player_now" href="#async_hll_rcon.connection.HllConnection.switch_player_now">switch_player_now</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.switch_player_on_death" href="#async_hll_rcon.connection.HllConnection.switch_player_on_death">switch_player_on_death</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.tcp_timeout" href="#async_hll_rcon.connection.HllConnection.tcp_timeout">tcp_timeout</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.temp_ban_player" href="#async_hll_rcon.connection.HllConnection.temp_ban_player">temp_ban_player</a></code></li>
<li><code><a title="async_hll_rcon.connection.HllConnection.uncensor_words" href="#async_hll_rcon.connection.HllConnection.uncensor_words">uncensor_words</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>